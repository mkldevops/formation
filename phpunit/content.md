name: inverse
class: center, middle, inverse

<img src="img/logo.svg" alt="PHPUnit" width="400px" style="margin-bottom:4rem" />

<div class="logo"><svg class="logo-1" fill="white" width="196" height="64" viewBox="0 0 196 64" style="fill-rule: evenodd; clip-rule: evenodd; stroke-linejoin: round; stroke-miterlimit: 2;"><g transform="matrix(0.101031,0,0,0.101031,2.39526,-0.329946)"><g transform="matrix(1.27705,0,0,1.27705,1143.65,155.404)"><path d="M320.958,94.576C320.958,107.301 317.357,117.884 310.155,126.323C302.952,134.763 293.386,140.971 281.456,144.947L331.695,223.685L290.072,223.685L246.727,150.647L230.025,150.647L230.025,223.685L193.837,223.685L193.837,40.361L247.787,40.361C296.568,40.361 320.958,58.433 320.958,94.576ZM283.312,94.576C283.312,84.855 280.462,77.764 274.762,73.301C269.062,68.838 260.38,66.607 248.715,66.607L230.025,66.607L230.025,124.931L249.908,124.931C260.954,124.931 269.283,122.501 274.895,117.641C280.506,112.78 283.312,105.092 283.312,94.576Z" style="fill-rule: nonzero;"></path></g><g transform="matrix(1.27705,0,0,1.27705,1486.87,208.548)"><path d="M313.005,64.751L241.159,227.264L208.153,217.058L277.612,67.402L195.163,67.402L195.163,40.361L313.005,40.361L313.005,64.751Z" style="fill-rule: nonzero;"></path></g><g transform="matrix(1.27705,0,0,1.27705,1335.53,155.404)"><path d="M253.752,12.524C257.994,12.524 261.75,13.43 265.019,15.241C268.289,17.053 270.852,19.55 272.708,22.731C274.563,25.912 275.491,29.447 275.491,33.335C275.491,37.224 274.563,40.758 272.708,43.94C270.852,47.121 268.289,49.64 265.019,51.495C261.75,53.351 257.994,54.279 253.752,54.279C249.51,54.279 245.733,53.351 242.419,51.495C239.105,49.64 236.52,47.121 234.664,43.94C232.808,40.758 231.88,37.224 231.88,33.335C231.88,29.447 232.808,25.912 234.664,22.731C236.52,19.55 239.105,17.053 242.419,15.241C245.733,13.43 249.51,12.524 253.752,12.524ZM201.658,83.309L276.419,83.309L276.419,198.897L313.402,198.897L313.402,223.685L200.332,223.685L200.332,198.897L241.424,198.897L241.424,108.097L201.658,108.097L201.658,83.309Z" style="fill-rule: nonzero;"></path></g><g transform="matrix(2.01117,0,0,2.01117,165.834,-128.735)"><path d="M261.043,177.319L211.622,177.319L211.622,218.681L254.382,218.681L254.382,228.302L211.622,228.302L211.622,271.803L264.332,271.803L264.332,280.93L201.096,280.93L201.096,167.944L262.441,167.944L261.043,177.319ZM213.76,150.758L245.501,134.23L250.682,143.851L216.72,156.432L213.76,150.758Z" style="fill-rule: nonzero;"></path></g><g transform="matrix(2.01117,0,0,2.01117,165.834,-128.735)"><path d="M312.861,273.201C321.248,273.201 329.06,270.651 336.297,265.553L341.642,272.46C337.969,275.53 333.501,277.984 328.238,279.82C322.975,281.657 317.987,282.575 313.272,282.575C304.994,282.575 297.922,280.766 292.056,277.148C286.191,273.529 281.723,268.376 278.653,261.688C275.583,255 274.048,247.133 274.048,238.088C274.048,229.426 275.583,221.696 278.653,214.898C281.723,208.101 286.218,202.756 292.139,198.863C298.059,194.971 305.131,193.025 313.354,193.025C323.935,193.025 333.282,196.287 341.395,202.81L335.968,210.129C328.128,204.757 320.426,202.07 312.861,202.07C307.488,202.07 302.733,203.441 298.594,206.182C294.455,208.923 291.22,212.993 288.89,218.393C286.561,223.793 285.396,230.358 285.396,238.088C285.396,245.927 286.547,252.465 288.849,257.7C291.152,262.935 294.373,266.828 298.512,269.377C302.65,271.926 307.434,273.201 312.861,273.201Z" style="fill-rule: nonzero;"></path></g><g transform="matrix(2.01117,0,0,2.01117,165.834,-128.735)"><path d="M386.388,193.025C394.118,193.025 400.641,194.834 405.959,198.452C411.277,202.07 415.251,207.224 417.883,213.912C420.514,220.6 421.83,228.549 421.83,237.759C421.83,246.421 420.473,254.137 417.759,260.907C415.046,267.677 411.003,272.981 405.63,276.819C400.258,280.656 393.761,282.575 386.141,282.575C378.412,282.575 371.874,280.725 366.529,277.024C361.184,273.324 357.168,268.13 354.482,261.441C351.796,254.753 350.453,246.914 350.453,237.923C350.453,228.987 351.81,221.148 354.523,214.405C357.237,207.662 361.294,202.413 366.694,198.658C372.093,194.903 378.658,193.025 386.388,193.025ZM386.388,201.988C369.887,201.988 361.636,213.967 361.636,237.923C361.636,261.661 369.805,273.529 386.141,273.529C402.478,273.529 410.646,261.606 410.646,237.759C410.646,213.912 402.56,201.988 386.388,201.988Z" style="fill-rule: nonzero;"></path></g><g transform="matrix(2.01117,0,0,2.01117,165.834,-128.735)"><path d="M463.945,261.359C463.945,265.635 465.301,268.76 468.015,270.734C470.729,272.707 474.443,273.694 479.157,273.694C483.982,273.694 489.053,272.652 494.37,270.569L497.33,278.463C494.973,279.669 492.136,280.656 488.82,281.424C485.503,282.191 481.953,282.575 478.171,282.575C473.566,282.575 469.413,281.739 465.713,280.067C462.012,278.395 459.093,275.955 456.955,272.748C454.817,269.541 453.748,265.745 453.748,261.359L453.748,168.52L426.94,168.52L426.94,159.639L463.945,159.639L463.945,261.359Z" style="fill-rule: nonzero;"></path></g><g transform="matrix(2.01117,0,0,2.01117,165.834,-128.735)"><path d="M520.121,241.87C520.231,248.833 521.491,254.657 523.904,259.345C526.316,264.032 529.509,267.513 533.483,269.788C537.458,272.063 541.885,273.201 546.764,273.201C551.15,273.201 555.11,272.57 558.646,271.309C562.182,270.048 565.979,268.02 570.035,265.224L575.38,272.872C571.433,275.942 566.952,278.326 561.936,280.026C556.919,281.725 551.999,282.575 547.175,282.575C539.336,282.575 532.552,280.725 526.823,277.024C521.094,273.324 516.722,268.102 513.707,261.359C510.692,254.616 509.184,246.777 509.184,237.841C509.184,229.125 510.705,221.381 513.748,214.611C516.791,207.84 521.08,202.55 526.617,198.74C532.154,194.93 538.486,193.025 545.613,193.025C552.52,193.025 558.496,194.711 563.539,198.082C568.583,201.454 572.434,206.278 575.093,212.555C577.751,218.832 579.081,226.246 579.081,234.798C579.081,236.059 578.999,238.417 578.834,241.87L520.121,241.87ZM545.859,202.564C541.09,202.564 536.855,203.674 533.155,205.894C529.454,208.114 526.48,211.472 524.232,215.967C521.985,220.463 520.669,226.027 520.285,232.66L569.377,232.66C569.158,222.793 566.938,215.31 562.717,210.211C558.496,205.113 552.876,202.564 545.859,202.564Z" style="fill-rule: nonzero;"></path></g><path d="M250.428,75.558C385.339,75.558 494.87,185.089 494.87,320C494.87,454.911 385.339,564.442 250.428,564.442C115.517,564.442 5.986,454.911 5.986,320C5.986,185.089 115.517,75.558 250.428,75.558ZM131.233,450.023L131.233,203.31L220.202,205.493C297.709,207.676 311.355,209.314 331.55,219.685C400.87,255.709 417.79,343.587 365.937,402.536L344.65,426.552L356.658,438.014L368.12,450.023L256.772,450.023L256.772,339.22L269.872,351.228L282.972,363.782L294.434,352.32C308.08,338.674 309.171,325.575 297.163,309.2C294.835,305.797 292.624,303.334 289.625,301.561C283.483,297.931 274.034,297.192 253.497,297.192L218.564,297.192L218.564,450.023L131.233,450.023Z"></path></g></svg></div>

---

class: middle
.center[
### Programme
]
.pull-left[
**Introduction**
  * Qu'est-ce que le testing et pourquoi est-il important ?
  * Présentation de PHPUnit et Symfony
  * Types de tests : unitaires, d'intégration, fonctionnels et end-to-end (e2e)

**Installation et configuration de l'environnement de développement**
  * Installation de Symfony
  * Installation de PHPUnit via Composer
  * Configuration de base de PHPUnit

**Tests unitaires**
* Qu'est-ce qu'un test unitaire ?
* Écrire des tests unitaires avec PHPUnit
* Les assertions de PHPUnit
* Utilisation de mocks et stubs pour isoler les dépendances

**Tests d'intégration**
* Qu'est-ce qu'un test d'intégration ?
* Écrire des tests d'intégration avec PHPUnit et Symfony
* Utilisation de la base de données dans les tests
* Utilisation de l'ORM Doctrine
]
.pull-right[
**Tests fonctionnels**
* Qu'est-ce qu'un test fonctionnel ?
* Écrire des tests fonctionnels avec PHPUnit et Symfony
* Utilisation du composant BrowserKit pour simuler des requêtes HTTP
* Tester les formulaires

**Tests end-to-end**
* Qu'est-ce qu'un test end-to-end ?
* Écrire des tests end-to-end avec PHPUnit et Symfony
* Utilisation du composant Panther pour piloter un navigateur web
* Tester une application en interaction avec un navigateur

**Conclusion**
* Les bonnes pratiques pour écrire des tests efficaces
* Intégration des tests dans un processus d'intégration continue
* Les outils et services pour gérer les tests dans un projet Symfony
]

---

class: middle, center, inverse

# Introduction

---
class: middle

#### Qu'est-ce que le testing et pourquoi est-il important ?

**Le testing, ou l'écriture de tests,** est un élément essentiel du développement logiciel qui vise à garantir la qualité et la fiabilité d'un programme. Il consiste à vérifier que le code fonctionne comme prévu et qu'il répond correctement aux différentes exigences et scénarios d'utilisation. Le testing est important pour plusieurs raisons :

* Il permet de détecter et de **corriger les erreurs avant qu'elles n'affectent les utilisateurs finaux.**

* Il facilite la maintenance et l'évolution du code en **évitant les régressions et en documentant le comportement attendu.**

* Il favorise la collaboration entre les développeurs en **instaurant un environnement de confiance et en facilitant la révision du code.**

* Il réduit les coûts à long terme en **minimisant les risques d'incidents et en améliorant la qualité** globale du logiciel.


#### Présentation de PHPUnit et Symfony

**PHPUnit est un framework de testing pour PHP,** qui est largement utilisé pour écrire des tests automatisés pour les applications PHP. Il permet de créer des tests unitaires, d'intégration et fonctionnels pour les applications PHP et offre une variété d'outils et d'assertions pour vérifier le comportement du code.

**Symfony**, quant à lui, est un framework de développement web PHP très populaire qui facilite la création et la maintenance d'applications web robustes et évolutives. Symfony est conçu pour être flexible et extensible, et intègre un certain nombre de composants réutilisables pour simplifier le développement. **Symfony et PHPUnit** fonctionnent bien ensemble et permettent de créer des tests pour les applications Symfony de manière simple et efficace.

---

class: middle

#### Les différents types de tests en PHP:

Il existe différents types de tests en PHP, chacun ayant un objectif différent:

* **Les tests unitaires:** Les tests unitaires sont utilisés pour tester les composants individuels d'une application. Ils sont écrits pour tester le comportement d'une méthode ou d'une classe spécifique et sont généralement exécutés rapidement. Les tests unitaires peuvent être utilisés pour garantir que chaque composant de l'application Symfony fonctionne comme prévu.

* **Les tests d'intégration:** Les tests d'intégration sont utilisés pour tester les interactions entre les différents composants de l'application. Les tests d'intégration peuvent être utilisés pour vérifier que les différents composants de l'application Symfony interagissent correctement.

* **Les tests fonctionnels:** Les tests fonctionnels sont utilisés pour tester le comportement de l'application du point de vue de l'utilisateur final. Les tests fonctionnels peuvent être utilisés pour s'assurer que l'application Symfony répond aux exigences fonctionnelles.

* **Les tests end-to-end:** Les tests end-to-end sont utilisés pour tester l'application dans son ensemble, en simulant des scénarios réels d'utilisation de l'application. Les tests end-to-end peuvent être utilisés pour s'assurer que l'application Symfony répond aux exigences de l'utilisateur final.

.pull-left[
Chacun de ces types de tests joue un rôle important dans la garantie de la qualité et la fiabilité du logiciel. Ils contribuent à assurer que chaque composant fonctionne correctement et que l'application dans son ensemble répond aux attentes des utilisateurs et des parties prenantes.

**En combinant ces différents types de tests,** les développeurs peuvent bâtir une stratégie de testing complète et efficace pour leur application.
]
.pull-right[
.center[
    <img src="img/phpunit-pyramid.png" alt="PHPUnit Pyramide" width="200" />
]
]

---
class: middle, inverse, center

# Installation et configuration
# de l'environnement de développement

---
class: middle

#### Installation de Symfony

Pour commencer la formation, il est nécessaire d'installer Symfony. Symfony est un framework PHP qui fournit un ensemble de composants pour construire des applications web modernes.

Durant cette formation nous allons utiliser **Gitpod** pour installer Symfony, il suffit d'utiliser le template suivant : https://github.com/mkl-devops-ri7/formation-symfony-template  

Suivons les étapes du `README.md` l'installation de symfony se fera automatiquement et lancera le projet sur le port `8080`.

**Configuration de l'environnement de développement**

Une fois Symfony installé, il est recommandé de configurer l'environnement de développement. Il est possible de créer un fichier `.env.local` à la racine du projet pour stocker les variables d'environnement spécifiques au développement.

Dans ce fichier, vous pouvez définir des paramètres tels que la configuration de la base de données. Nous utiliserons Sqlite comme base de données lors de cette formation. Ajoutez-y la configuration suivante :

```dotenv
# .env.local
DATABASE_URL="sqlite:///%kernel.project_dir%/var/data.db"
```

---
class: middle

#### Installation de PHPUnit via Composer

Une fois que Symfony est installé et configuré, connectez-vous au container via `make docker-sh`.

Vous pouvez installer PHPUnit en utilisant **Composer**. PHPUnit est disponible sous forme de paquet Composer, qui peut être installé en utilisant la commande suivante :

```bash
symfony composer require tests
```

Cette commande installera PHPUnit dans le répertoire `vendor` de votre projet et ajoutera également une entrée pour PHPUnit dans le fichier `composer.json` de votre projet.

Pour exécuter les tests unitaires avec PHPUnit, vous pouvez utiliser la commande suivante :

```bash
symfony php bin/phpunit
```


---

class: middle

####  Configuration de base de PHPUnit

PHPUnit utilise un fichier de configuration XML pour déterminer comment exécuter les tests. Dans un projet Symfony, ce fichier se nomme généralement phpunit.xml.dist et se trouve à la racine du projet.  C'est le fichier de configuration principal pour PHPUnit. Il permet de définir les paramètres globaux, les répertoires de test et les options d'exécution pour les tests de votre projet. Voici quelques détails sur les éléments couramment utilisés dans ce fichier .

.pull-left[
* **`<phpunit>` :** L'élément racine du fichier de configuration. Il contient plusieurs attributs importants :
  * `colors` : Active ou désactive l'affichage des couleurs dans la sortie du terminal (défaut : false).
  * `bootstrap` : Spécifie le fichier PHP à inclure avant l'exécution des tests.
* **`<testsuites>` :** Contient une ou plusieurs balises `<testsuite>`, chacune définissant un ensemble de tests. Chaque `testsuite` doit avoir un nom unique et peut inclure un ou plusieurs répertoires contenant les fichiers de test.
* **`<coverage>` :** configure la couverture de code pour PHPUnit. Elle permet d'inclure ou d'exclure des fichiers ou des répertoires spécifiques lors du calcul de la couverture.
* **`<php>` :** Contient des éléments de configuration spécifiques à PHP, tels que les options `ini` et les variables d'environnement (env et server). Par exemple, on peut définir le niveau de rapport d'erreur de PHP ou configurer l'environnement de l'application (`APP_ENV`) pour les tests.
]
.pull-right[
```xml
<?xml version="1.0" encoding="UTF-8"?>
<phpunit xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         colors="true"
         bootstrap="tests/bootstrap.php"
>
    <php>
        <ini name="display_errors" value="1" />
        <ini name="error_reporting" value="-1" />
        <server name="APP_ENV" value="test" force="true" />
        <server name="SHELL_VERBOSITY" value="-1" />
        <server name="SYMFONY_PHPUNIT_REMOVE" value="" />
        <server name="SYMFONY_PHPUNIT_VERSION" value="9.5" />
    </php>

    <testsuites>
        <testsuite name="Project Test Suite">
            <directory>tests</directory>
        </testsuite>
    </testsuites>

    <coverage processUncoveredFiles="true">
        <include>
            <directory suffix=".php">src</directory>
        </include>
    </coverage>
</phpunit>
```

]
---

class: middle, center, inverse

# Tests unitaires

---
class: middle


#### Qu'est-ce qu'un test unitaire ?

Un test unitaire est un test automatisé qui vérifie le comportement d'une méthode ou d'une classe spécifique dans une application. Un test unitaire est conçu pour tester une petite partie de code, appelée "unité", afin de garantir que cette unité fonctionne correctement. 

Les tests unitaires doivent être écrits de manière à être indépendants des autres parties de l'application et doivent être facilement reproductibles.


Les tests unitaires sont également rapides à exécuter et permettent aux développeurs de détecter les erreurs plus tôt dans le processus de développement.

.center[
    <img src="img/phpunit-pyramid.png" alt="PHPUnit Pyramide" width="300" />
]
---
class: middle

#### Écrire des tests unitaires avec PHPUnit

PHPUnit fournit des outils pour écrire des tests unitaires en PHP. Les tests unitaires écrits avec PHPUnit sont généralement organisés en classes de test qui contiennent plusieurs méthodes de test. Chaque méthode de test est conçue pour tester une unité spécifique de code.

Voici un exemple simple de test unitaire écrit avec PHPUnit:

```php
use PHPUnit\Framework\TestCase;

class MyTest extends TestCase
{
    public function testAddition()
    {
        $result = 1 + 2;
        static::assertEquals(3, $result);
    }
}
```

Dans cet exemple, nous avons créé une classe de test `MyTest` qui hérite de la classe de test de base de PHPUnit `TestCase`. La méthode de test `testAddition` teste l'addition de deux nombres et vérifie que le résultat est égal à 3 à l'aide de la méthode d'assertion `assertEquals`.

---
class: middle

#### Les assertions de PHPUnit

PHPUnit fournit plusieurs méthodes d'assertion pour tester le comportement du code dans les tests unitaires. Voici quelques exemples d'assertions couramment utilisées:

* `assertEquals()`: Vérifie que deux valeurs sont égales.
* `assertTrue()`: Vérifie qu'une expression est vraie.
* `assertFalse()`: Vérifie qu'une expression est fausse.
* `assertInstanceOf()`: Vérifie qu'un objet est une instance d'une classe spécifique.
* `assertNull()`: Vérifie qu'une valeur est nulle.

Supposons que nous avons une entité `Book` dans notre application Symfony avec les propriétés suivantes : `id`, `title`, `author` et `year`.

Nous pouvons écrire un test unitaire pour cette entité pour nous assurer que les méthodes `getId`, `getTitle`, `getAuthor` et `getYear` ̀fonctionnent correctement.

---

class: middle

Voici un exemple de test unitaire pour cette entité :

```php
use PHPUnit\Framework\TestCase;
use App\Entity\Book;

class BookTest extends TestCase
{
    public function testGetId()
    {
        $book = new Book();
        $book->setId(1);
        static::assertEquals(1, $book->getId());
    }

    public function testGetTitle()
    {
        $book = new Book();
        $book->setTitle('Le Petit Prince');
        static::assertEquals('Le Petit Prince', $book->getTitle());
    }

    public function testGetAuthor()
    {
        $book = new Book();
        $book->setAuthor('Antoine de Saint-Exupéry');
        static::assertEquals('Antoine de Saint-Exupéry', $book->getAuthor());
    }
}
```

---
class: middle

#### Utilisation de mocks et stubs pour isoler les dépendances

Lors des tests, il est souvent nécessaire d'isoler les dépendances pour éviter que des éléments externes, tels que les bases de données ou les services web, n'affectent les résultats des tests. **Les mocks et les stubs** sont des objets de substitution qui imitent le comportement des dépendances réelles, permettant ainsi de contrôler et de simuler les interactions entre les objets.

##### Les mocks

.pull-left[

Considérez l'exemple suivant avec les classes `Book` et `Category` :

```php
class Category
{
    public function getName(): string
    {
        // Retourne le nom de la catégorie
    }
}

class Book
{
    private $category;

    public function __construct(Category $category)
    {
        $this->category = $category;
    }

    public function getCategoryName(): string
    {
        return $this->category->getName();
    }
}
```
]
.pull-right[
  Pour tester la classe Book, nous pouvons créer un mock de la classe Category à l'aide de PHPUnit :

```php
namespace App\Tests;

use App\Book;
use App\Category;
use PHPUnit\Framework\TestCase;

class BookTest extends TestCase
{
    public function testGetCategoryName()
    {
        // Crée un mock de la classe Category
        $categoryMock = $this->createMock(Category::class);

        // Configure le mock pour retourner 'Fiction' lors de l'appel à la méthode 'getName'
        $categoryMock->method('getName')->willReturn('Fiction');

        // Utilise le mock de Category lors de la création de l'instance de Book
        $book = new Book($categoryMock);

        // Teste si la méthode 'getCategoryName' retourne le nom de la catégorie défini par le mock
        $this->assertEquals('Fiction', $book->getCategoryName());
    }
}
```
]

---
class: middle

##### Les stubs

Les stubs sont similaires aux mocks en ce sens qu'ils sont également utilisés pour remplacer des dépendances réelles par des objets de substitution. Cependant, les stubs sont généralement plus simples et se concentrent sur la fourniture de réponses prédéfinies aux appels de méthodes, sans se préoccuper du nombre ou de l'ordre des appels.

Dans l'exemple précédent avec les classes `Book` et `Category`, nous pouvons également utiliser un stub pour remplacer la dépendance Category. Voici comment créer un stub avec PHPUnit en utilisant la méthode `getMockBuilder()`:

.pull-left[
```php
namespace App\Tests;

use App\Book;
use App\Category;
use PHPUnit\Framework\TestCase;

class BookTest extends TestCase
{
  public function testGetCategoryName()
  {
    // Crée un stub de la classe Category
    $categoryStub = $this->getMockBuilder(Category::class)
                          ->setMethods(['getName'])
                          ->getMock();

    // Configure le stub pour retourner 'Fiction' lors de l'appel à la méthode 'getName'
    $categoryStub->method('getName')->willReturn('Fiction');

    // Utilise le stub de Category lors de la création de l'instance de Book
    $book = new Book($categoryStub);

    // Teste si la méthode 'getCategoryName' retourne le nom de la catégorie défini par le stub
    $this->assertEquals('Fiction', $book->getCategoryName());
  }
}
```
]
.pull-right[
Dans cet exemple, nous utilisons `getMockBuilder()` pour créer un stub de la classe `Category`. Nous spécifions les méthodes à remplacer avec `setMethods()` et appelons `getMock()` pour générer le stub. Ensuite, nous configurons le stub pour retourner une valeur prédéfinie ('Fiction') lors de l'appel à la méthode `getName()`.

Notez que, dans cet exemple, la différence entre un mock et un stub est minime, car PHPUnit utilise la même classe `MockObject` pour créer les deux. Cependant, la distinction conceptuelle entre les mocks et les stubs est importante: les mocks vérifient les interactions et les comportements, tandis que les stubs fournissent des réponses prédéfinies sans se préoccuper des détails des interactions.
]

---

class: middle, center, inverse

# Tests d'intégration

---

class: middle

#### Qu'est-ce qu'un test d'intégration ?

Les tests d'intégration visent à vérifier la bonne interaction entre plusieurs composants ou modules d'une application. Contrairement aux tests unitaires, qui se concentrent sur le fonctionnement individuel des composants, les tests d'intégration valident que l'ensemble des composants fonctionne correctement lorsqu'ils sont combinés.

Les tests d'intégration sont généralement plus lents que les tests unitaires, car ils nécessitent de créer un environnement d'exécution complet pour l'application. Cependant, ils sont souvent plus efficaces pour détecter les problèmes de fonctionnement de l'application.

.center[
    <img src="img/phpunit-pyramid.png" alt="PHPUnit Pyramide" width="300" />
]

---

class: middle

#### Écrire des tests d'intégration avec PHPUnit et Symfony

Les tests d'intégration sont souvent réalisés en utilisant le composant `KernelTestCase` de Symfony, qui permet de tester les interactions entre les différents composants de l'application sans passer par le client HTTP.

Ce composant étend la classe `TestCase` de PHPUnit et offre des fonctionnalités supplémentaires pour tester les interactions entre les différentes parties de l'application, notamment les services et les bases de données.

Imaginons que nous avons un service BookFormatter qui formate le titre et l'auteur d'un livre en une chaîne de caractères.

```php
namespace App\Service;

use App\Entity\Book;

class BookFormatter
{
    public function format(Book $book): string
    {
        return sprintf('%s by %s', $book->getTitle(), $book->getAuthor());
    }
}
```

---

class: middle

.pull-left[
Définissez le test d'intégration pour le service `BookFormatter` en utilisant `KernelTestCase` :

```php
namespace App\Tests;

use App\Entity\Book;
use App\Service\BookFormatter;
use Symfony\Bundle\FrameworkBundle\Test\KernelTestCase;

class BookFormatterTest extends KernelTestCase
{
    public function testFormatBookInfo()
    {
        // Initialise le noyau et le conteneur pour accéder aux services
        self::bootKernel();
        $container = self::$kernel->getContainer();

        // Récupère le service BookFormatter
        $bookFormatter = $container->get(BookFormatter::class);

        // Crée un nouveau livre
        $book = (new Book())
          ->setTitle('Test Book')
          ->setAuthor('John Doe');

        // Formate les informations du livre
        $formattedInfo = $bookFormatter->format($book);

        // Vérifie si les informations du livre sont correctement formatées
        static::assertEquals('Test Book by John Doe', $formattedInfo);
    }
}
```
]
.pull-right[

Dans cet exemple, nous utilisons la classe `KernelTestCase` pour initialiser le noyau et accéder au conteneur de services. Nous récupérons ensuite le service `BookFormatter` et créons un nouveau livre avec un titre et un auteur. Enfin, nous appelons la méthode `format()` pour formater les informations du livre et vérifions que la chaîne de caractères retournée est correctement formatée.

Cet exemple illustre comment écrire un test d'intégration pour un service personnalisé en utilisant `KernelTestCase`, indépendamment de Doctrine ou d'autres services tiers.

La classe `KernelTestCase` est idéale pour les tests d'intégration qui n'impliquent pas de requêtes HTTP et permet d'écrire des tests plus rapides et plus ciblés sur les interactions entre les composants de l'application.
]

---

class: middle

#### Utilisation de la base de données dans les tests

Pour utiliser une base de données dans les tests d'intégration, il est recommandé de créer une base de données de test séparée afin de ne pas affecter les données de production. Dans le fichier `.env.test` de votre projet Symfony, modifiez la variable `DATABASE_URL` pour pointer vers votre base de données de test.

```bash
DATABASE_URL="sqlite:///%kernel.project_dir%/var/test.db"
```

---
class: middle

#### Utilisation de l'ORM Doctrine

Lors de l'écriture de tests d'intégration avec Symfony, vous pouvez utiliser l'ORM Doctrine pour interagir avec la base de données de test. Voici un exemple de test d'intégration qui utilise Doctrine pour tester la récupération d'un livre par son identifiant :

.pull-left[

```php
namespace App\Tests;

use App\Entity\Book;
use App\Repository\BookRepository;
use Symfony\Bundle\FrameworkBundle\Test\KernelTestCase;

class BookRepositoryTest extends KernelTestCase
{
    public function testFindById()
    {
        self::bootKernel();
        $container = self::$kernel->getContainer();

        // Récupère le repository du livre
        $bookRepository = $container->get(BookRepository::class);

        $book = (new Book())
          ->setTitle('Test Book')
          ->setAuthor('John Doe');

        $entityManager = $container->get(EntityManagerInterface::class);
        $entityManager->persist($book);
        $entityManager->flush();

        // Recherche le livre par son identifiant
        $foundBook = $bookRepository->find($book->getId());

        // Vérifie si le livre récupéré correspond au livre créé
        static::assertSame($book, $foundBook);
    }
}
```
]

.pull-right[
Dans cet exemple, nous utilisons la classe `KernelTestCase` pour initialiser le kernel et accéder aux services de l'application. Nous récupérons le repository de la classe `Book`, créons un nouveau livre et l'enregistrons dans la base de données de test. Enfin, nous recherchons le livre par son identifiant et vérifions que le livre récupéré correspond au livre créé.

Ce test d'intégration illustre comment utiliser Symfony, PHPUnit et Doctrine pour tester les interactions entre les composants de l'application et la base de données.
]

---

class: middle, center, inverse

# Tests fonctionnels

---

class: middle

#### Qu'est-ce qu'un test fonctionnel ?

**Les tests fonctionnels** visent à vérifier le comportement de l'application du point de vue de l'utilisateur final. Ils se concentrent sur la manière dont les fonctionnalités sont présentées et utilisées, en évaluant l'interaction entre l'interface utilisateur, le code backend et les autres composants de l'application.

Les tests fonctionnels simulent généralement des actions utilisateur, telles que la navigation, le remplissage de formulaires et la soumission de données.


